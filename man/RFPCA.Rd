% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RFPCA.R
\name{RFPCA}
\alias{RFPCA}
\title{Riemannian Functional Principal Component Analysis}
\usage{
RFPCA(Ly, Lt, optns = list())
}
\arguments{
\item{Ly}{A list of matrices, each being D by n_i containing the observed values for individual i. In each matrix, columes corresponds to different time points, and rows corresponds to different dimensions.}

\item{Lt}{A list of \emph{n} vectors containing the observation time points for each individual corresponding to y. Each vector should be sorted in ascending order.}

\item{optns}{A list of options control parameters specified by \code{list(name=value)}. See `Details'.}
}
\value{
A list containing the following fields:
\item{muReg}{A D by nRegGrid matrix containing the mean function estimate on regGrid.}
\item{muWork}{A D by nWorkGrid matrix containing the mean function estimate on workGrid.}
\item{muObs}{A D by nObsGrid matrix containing the mean function estimate on obsGrid.}
\item{cov}{An nWorkGrid by nWorkGrid by D by D array of the smoothed covariance surface.}
\item{covObs}{An nObsGrid by nObsGrid by D by D array of the smoothed covariance surface interpolated onto the obsGrid.}
\item{phi}{An nWorkGrid by D by \emph{K} array containing eigenfunctions supported on workGrid, where D is the ambient dimension.}
\item{phiObsTrunc}{A possibly truncated version of phi, supported on the truncated obsGrid}
\item{lambda}{A vector of length \emph{K} containing eigenvalues.}
\item{xi}{A \emph{n} by \emph{K} matrix containing the FPC estimates.} 
\item{sigma2}{Variance for measure error.}
\item{obsGrid}{The (sorted) grid points where all observation points are pooled.}
\item{regGrid}{A vector of length nRegGrid. The internal regular grid on which the eigen analysis is carried on.}
\item{workGrid}{Duplicates regGrid. A vector of length nWorkGrid. The internal regular grid on which the eigen analysis is carried on.}
\item{workGridTrunc}{A possibly truncated version of regGrid.}
\item{K}{Number of components returned}
\item{userBwMu}{The selected (or user specified) bandwidth for smoothing the mean function.}
\item{userBwCov}{The selected (or user specified) bandwidth for smoothing the covariance function.}
\item{mfd}{The manifold on which the analysis is performed.}
\item{optns}{A list of actually used options.}
}
\description{
FPCA for Riemannian manifold-valued functional data. The Riemannian (or multi-dimensional) functional data can be dense or sparse.
}
\details{
Supported classes includes: 'Sphere' (default), 'Euclidean', 'SO' 

Available control options are 
\describe{
item{mfd}{A structure such as structure(1, class='CLASS'), where CLASS is one of the supported classes above. Takes precedence over mfdName. Default: structure(1, 'Sphere')}
item{mfdName}{The name of a manifold. Supported values are 'Sphere', 'Euclidean', 'SO', 'L2'. Default: 'Sphere'}
item{dataType}{The type of design we have (usually distinguishing between sparse or dense functional data); 'Sparse', 'Dense', 'DenseWithMV', 'p>>n'. Default:  determine automatically based on 'IsRegular'}
item{userBwMu}{The bandwidth for smoothing the mean function. Can be either a scalar specifying the bandwidth, or 'GCV' for generalized cross-validation. MUST BE SPECIFIED}
item{userBwCov}{The bandwidth for smoothing the covariance function. Can be a scalar specifying the bandwidth. If userBwCov = 'GCV', then userBwCov will be set to twice the GCV-selected bandwidth for mu. MUST BE SPECIFIED}
item{ToutRange}{Truncate the FPCA to be only within ToutRange. Default: c(-Inf, Inf)}
item{npoly}{The degree of local polynomials for smoothing. Default: 1 (local linear)}
item{nRegGrid}{The number of support points in each direction of covariance surface. Default: 51}
item{kernel}{Smoothing kernel choice, common for mu and covariance; "rect", "gauss", "epan", "gausvar", "quar". Default: "gauss"; dense data are assumed noise-less so no smoothing is performed. }
item{error}{Assume measurement error in the dataset. The error is assumed to be isometric on the tangent space. Default: TRUE}
item{maxK}{The maximum number of principal components to consider. Default: Inf if the smoothing method is used, and 30 for cross-sectional estimate}
item{userSigma2}{The user-defined measurement error variance. A positive scalar. Default: `NULL`}
item{methodMuCovEst}{The method to estimate the mean and covariance in the case of dense functional data; 'cross-sectional', 'smooth'. Default: 'cross-sectional'}
item{methodXi}{The method to estimate the PC scores; 'CE' (Condit. Expectation), 'IN' (Numerical Integration). Default: 'CE' for sparse data and dense data with missing values, 'IN' for dense data.}
item{obsGridOnly}{If TRUE, then assume the observation grids are regular, and use it as the regGrid/workGrid. This may speed up the grid convertion and eigendecomposition if length(obsGrid) is small. Default: TRUE if the Lt are regular and length(obsGrid) <= nRegGrid, and FALSE otherwise.}
}
}
\examples{
# First simulate some data
set.seed(1)
n <- 50
m <- 20 # Number of different pooled time points
K <- 20
lambda <- 0.07 ^ (seq_len(K) / 2)
D <- 3
basisType <- 'legendre01'
sparsity <- 5:15
sigma2 <- 0.01
muList <- list(
  function(x) x * 2, 
  function(x) sin(x * 1 * pi) * pi / 2 * 0.6,
  function(x) rep(0, length(x))
)
pts <- seq(0, 1, length.out=m)
mfd <- structure(1, class='Euclidean')
mu <- Makemu(mfd, muList, c(rep(0, p - 1), 1), pts)

# Generate noisy samples
# CreateBasis <- fdapace:::CreateBasis
samp <- MakeMfdProcess(mfd, n, mu, pts, K = K, lambda=lambda, basisType=basisType, sigma2=sigma2)
spSamp <- SparsifyM(samp$X, samp$T, sparsity)
yList <- spSamp$Ly
tList <- spSamp$Lt

# Fit model
bw <- 0.2
kern <- 'epan'

resEu <- RFPCA(yList, tList, list(userBwMu=bw, userBwCov=bw * 2, kernel=kern, maxK=K, mfdName='euclidean', error=TRUE))

# Solid curve stands for the true mean and dashed for the estimated mean function.
matplot(pts, t(mu), type='l', lty=1)
matplot(pts, t(resEu$muObs), type='l', lty=2, add=TRUE)

# Up to the 3rd principal components were well-estimated
plot(resEu$xi[, 3], samp$xi[, 3]) 

}
