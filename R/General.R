## S3 methods

#' Returns the Riemannian metric
#'
#' @param mfd A manifold object created by \code{\link{createM}}
#' @param p A vector containing the (single) base point on the manifold.
#' @param U,V Matrices with n columns each containing a tangent vector. The metric of each pair of n columns is calculated. 
#'
#' @export
metric <- function(mfd, p, U, V) {
  UseMethod("metric", mfd)
}

#' Norm on the tangent space induced by the Riemannian metric
#' @param mfd A manifold object created by \code{\link{createM}}
#' @param p,U Matrices with n columns. p stands for the base point(s) and U the tangent vector(s). The norm of each column in U is calculated w.r.t. the corresponding column in p. 
#' @export
norm <- function(mfd, p, U) {
  UseMethod("norm", mfd)
}


#' Geodesic distance
#' @param mfd A manifold object created by \code{\link{createM}}
#' @param X,Y Matrices with n columns. The distance between each pair of columns is calculated. If either X or Y is a vector then it is recycled.
#' @export
distance <- function(mfd, X, Y) {
  UseMethod("distance", mfd)
}


#' Obtain the geodesic curve
#' @param mfd A manifold object created by \code{\link{createM}}
#' @export
geodesicCurve <- function(mfd, p, h, t) {
  UseMethod("geodesicCurve", mfd)
}


#' Riemannian exponential map
#' @param mfd A manifold object created by \code{\link{createM}}
#' @param p,V Matrices with n columns. The exponential map of each column in V is calculated w.r.t. the corresponding column in p. 
#' @export
rieExp <- function(mfd, p, V) {
  UseMethod("rieExp", mfd)
}


#' Riemannian logarithm map
#' @param mfd A manifold object created by \code{\link{createM}}
#' @param p,X Matrices with n columns. The logarithm map of each column in X is calculated w.r.t. the corresponding column in p. 
#' @export
rieLog <- function(mfd, p, X) {
  UseMethod("rieLog", mfd)
}


#' Project data points in the ambient space onto the manifold
#' @param mfd A manifold object created by \code{\link{createM}}
#' @param p A matrix of points to be projected to the manifold.
#' @export
project <- function(mfd, p) {
  UseMethod("project", mfd)
}


# TODO: 
geopolate <- function(mfd, ...) UseMethod("geopolate", mfd)


#' Project data points in the ambient space onto the tangent space
#'
#' @param mfd A manifold object created by \code{\link{createM}}
#' @param p A vector containing the base point on the manifold. Data X will be projected onto the tangent space of p.
#' @param X A vector or a matrix containing the data points in terms of the coordinates in the ambient space.
#' @param projMatOnly Whether to only return the projection matrix (FALSE) or the projected data points (TRUE, the default)
#' @export
projectTangent <- function(mfd, ...) UseMethod('projectTangent', mfd)


#' Generate noise on the tangent space
#'
#' For each time point (column in mu), generate n isotropic noises distributed as epsFun on the tangent space at mu(t)
#' @param mfd A manifold object created by \code{\link{createM}}
#' @param n Sample size
#' @param mu A matrix or a vector containing the base point(s)
#' @param sigam2 The isotropic variance on the tangent space
#' @param epsFun The distribution for generating the univariate errors with unit variance for the tangent space coordinates
#' 
#' @return An array with size (n, dimIntrinsic, nPts) 
NoiseTangent <- function(mfd, n, mu, sigma2=0, epsFun = rnorm) {
  UseMethod('NoiseTangent', mfd)
}


#' Calculate the Fréchet median
#' @param mfd A manifold object created by \code{\link{createM}}
#' @param X A matrix with each column being a point on the manifold.
#' @export
frechetMedian <- function(mfd, X, ...) UseMethod("frechetMedian", mfd)


#' Calculate the Fréchet mean
#' @param mfd A manifold object created by \code{\link{createM}}
#' @param X A matrix with each column being a point on the manifold.
#' @export
frechetMean <- function(mfd, X, ...) UseMethod("frechetMean", mfd)


#' Generate random variables on the manifold
#'
#' By default, random variables are generated by mapping isotropic Gaussian distributions on the tangent space back to the manifold using the exponential map
#' @param mfd A manifold object created by \code{\link{createM}}
#' @param n Sample size
#' @param dimIntrinsic The intrinsic dimension of the target manifold
#' @export
rmfd <- function(mfd, n, dimIntrinsic, ...) UseMethod("rmfd", mfd)


#' Returns the origin of the manifold
#' 
#' Each manifold defined in this package has been designated a more or less reasonable choice of origin.
#' @param mfd A manifold object created by \code{\link{createM}}
#' @export
origin <- function(mfd, dimIntrinsic, ...) UseMethod('origin', mfd)


#' Transform the coordinates for the tangent space into a tangent vector
#' @param mfd A manifold object created by \code{\link{createM}}
#' @param p A vector for the base point 
#' @param V0 A matrix or a vector containing the coordinates
#' @export
coordToTanV <- function(mfd, p, V0, ...) {
  if (!missing(p)) {
    if (length(p) == 0) {
      stop('`p` cannot have length 0')
    }
    if (is.matrix(p) && ncol(p) > 1) {
      stop('`p` must be a single point')
    }
  }
  if (length(V0) == 0) {
    stop('`V` cannot have length 0')
  }
  UseMethod('coordToTanV', mfd)
}


#' Transform tangent vectors to their coordinates on the tangent space
#' @param mfd A manifold object created by \code{\link{createM}}
#' @param p A vector for the base point 
#' @param V A matrix or a vector containing the tangent vectors
#' @export
tanVToCoord <- function(mfd, p, V, ...) {

  if (!missing(p)) {
    if (length(p) == 0) {
      stop('`p` cannot have length 0')
    }
    if (is.matrix(p) && ncol(p) > 1) {
      stop('`p` must be a single point')
    }
  }

  if (length(V) == 0) {
    stop('`V` cannot have length 0')
  }
  UseMethod('tanVToCoord', mfd)
}


#' Obtain a basis on the tangent space
#'
#' Parametric the tangent space at location p, so that the parametrized version contains an open neighborhood around the origin. (The dimension of v is potentially reduced). 
#' @param mfd A manifold object created by \code{\link{createM}}
#' @param p A vector for a base point on the manifold
#' @return An orthonormal basis matrix D, whose columns contain the basis vectors, so that D^T v give the coordinates v0 for a tangent vector v, and D%*%v0 = v.
#' @export
basisTan <- function(mfd, p) {
  UseMethod('basisTan')
}


# dotprod <- function(u, v) {
    # return(colSums(u*v))
# }


#' Dimensions in this package
#' 
#' `calcGeomPar` calculates geometric parameter.
#' `calcIntDim` calculates the intrinsic dimensions.
#' `calcAmbDim` calculates the ambient dimensions.
#' `calcTanDim` calculates the number of tuples used to represent a tangent vector.
#' @param mfd A manifold object created by \code{\link{createM}}
#' @param dimAmbient Dimension of the ambient space.
#' @param dimIntrinsic Intrinsic dimension of the manifold.
#' @param dimTangent The length of a tangent vector
#' @param geomPar The geometric parameter (e.g., SO(*))
#' @name dimensions
NULL
#> NULL


#' @export
#' @rdname dimensions
calcGeomPar <- function(mfd, dimAmbient, dimIntrinsic, dimTangent) {
  if ((!missing(dimAmbient)) + 
      (!missing(dimIntrinsic)) + 
      (!missing(dimTangent)) > 1) {
    stop('Can only specify one of dimIntrinsic, dimAmbient, and dimTangent')
  }
  UseMethod('calcGeomPar', mfd)
}


#' @export
#' @rdname dimensions
calcIntDim <- function(mfd, geomPar, dimAmbient, dimTangent) {
  if ((!missing(geomPar)) + 
      (!missing(dimAmbient)) + 
      (!missing(dimTangent)) > 1) {
    stop('Cannot specify two or more of the dimensions')
  }
  UseMethod('calcIntDim', mfd)
}


#' @export
#' @rdname dimensions
calcAmbDim <- function(mfd, geomPar, dimIntrinsic, dimTangent) {
  if ((!missing(geomPar)) + 
      (!missing(dimIntrinsic)) + 
      (!missing(dimTangent)) > 1) {
    stop('Cannot specify two or more of the dimensions')
  }
  UseMethod('calcAmbDim', mfd)
}


#' @export
#' @rdname dimensions
calcTanDim <- function(mfd, geomPar, dimAmbient, dimIntrinsic) {
  if ((!missing(geomPar)) + 
      (!missing(dimAmbient)) + 
      (!missing(dimIntrinsic)) > 1) {
    stop('Cannot specify two or more of the dimensions')
  }
  UseMethod('calcTanDim', mfd)
}


#' @describeIn metric Method
#' @export
metric.default <- function(mfd, p=NULL, U, V) {

  U <- as.matrix(U)
  V <- as.matrix(V)

  if ((ncol(U) <= 1 && ncol(V) >= 1) || (ncol(U) >= 1 && ncol(V) <= 1)) {
    c(crossprod(U, V))
  } else {
    colSums(U * V)
  }
}


#' @describeIn norm Method
#' @export
norm.default <- function(mfd, p=NULL, U) {
  U <- as.matrix(U)
  if ((!missing(p)) && (!is.null(p)) && (is.matrix(p) && ncol(p) > 1) && (ncol(U) == 1)) {
    U <- matrix(U, nrow(U), ncol(p))
  }
  sqrt(colSums(U * U))
}


#' @param p Optionally, specify the base point of the tangent space, on which random tangent vectors will be generated. Default to the origin of `mfd`. 
#' @param dist Either a string or a function, describing the distributions. If it is character, then independent univariate r.v. following that distribution with total variance 1 is generated on the tangent space. If it is a function, it should specify the generation of the samples on the tangent space _coordinates_ (with dimenension dimIntrinsic), and it must return a matrix for which the columns are the coordinates. Then it will be mapped to the tangent space at the origin and then to the manifold.
#' @export
#' @describeIn rmfd Default method
rmfd.default <- function(mfd, n, dimIntrinsic, p, dist=c('norm', 'unif', 'exp'), totalVar=1, ...) {

  if (!is.function(dist)) {
    dist <- match.arg(dist)
  }

  if (n == 0) {
    return(matrix(0, nrow=calcAmbDim(mfd, dimIntrinsic=dimIntrinsic), ncol=0))
  }

  if (dimIntrinsic == 0) {
    stop('`dimIntrinsic` must be at least one')
  }

  if (is.finiteDim(mfd)) {
    if (is.function(dist)) {
      V0 <- dist(n, dimIntrinsic, ...)
    } else {
      # Function for generating univariate r.v. with variance 1
      if (dist == 'norm') {
        runi <- function(x) rnorm(x)
      } else if (dist == 'unif') {
        runi <- function(x) runif(x, min=-sqrt(3), max=sqrt(3))
      } else if (dist == 'exp') {
        runi <- function(x) rexp(x) - 1
      }

      V0 <- matrix(runi(n * dimIntrinsic), dimIntrinsic, n) * sqrt(totalVar / dimIntrinsic)

    } 
  
    if (missing(p)) {
      p <- origin(mfd, dimIntrinsic=dimIntrinsic)
    }
    V <- coordToTanV(mfd, p, V0)
  } else { # For functional manifolds
    stop('to be implemented')
  }

  rieExp(mfd, p, V)
}


#' @export
#' @describeIn coordToTanV Method
coordToTanV.default <- function(mfd, p, V0) {
  D <- basisTan(mfd, p)
  D %*% as.matrix(V0)
}


#' @export
#' @describeIn tanVToCoord Method
tanVToCoord.default <- function(mfd, p, V) {
  D <- basisTan(mfd, p)
  t(D) %*% as.matrix(V)
}


#' List all available manifold names
#' @export
listAvailMfd <- function() {
  gsub('^.*\\.', '', as.character(methods(distance)))
}


#' Tell whether a manifold is a finite-dimensional one
#' @param mfd A manifold object created by \code{\link{createM}}
#' @export
is.finiteDim <- function(mfd) {
  if (!is.character(mfd)) {
    mfd <- class(mfd)
  }
  isFunctional <- mfd %in% c('HS', 'L2', 'Dens') 
  all(!isFunctional)
}

#' Create an object to symbolize the manifold. 
#'
#' Create an object to symbolize the manifold. Supports the Euclidean, the unit sphere, special orthogonal group, and symmetric positivec definite (SPD) matrices with either the affine invariant or the log-Euclidean metric.
#'
#' Overall, most of the arguments in the manifold functions respect recycling rules. If the input arguments are matrices with n rows corresponding to n points, then the manifold function will be applied to each of the n pairs; the returned value will be a matrix. If one input corresponds to n points and the other just one point, then the one point will be recycled. If each component corresponds to one point, the returned value will correspond to just one point.
#' @param mfdName One of 'Euclidean', 'Sphere', 'SO', 'AffInv', or 'LogEu'. The name is case sensitive.
#' @export
createM <- function(mfdName) {

  if (mfdName %in% c('AffInv', 'LogEu') ) {
    parent <- 'SPD'
  } else {
    parent <- character(0)
  }

  structure(1, class=c(mfdName, parent))
}


#' @param mu0 A matrix of starting points. Each column corresponds to a starting point. If there are multiple columns, then a multistart algorithm is used. 
#' @param weight A vector of weights for the observations
#' @param tol The threshold for determining convergence
#' @param maxit Maximum iteration
#' @param alpha The step size parameter. See Fletcher et al. (2008) CVPR
#' @export
#' @describeIn frechetMedian Default method
frechetMedian.default <- function(mfd, X, mu0, weight=NULL, tol=1e-9, maxit=1000, alpha=1) {

  X <- as.matrix(X)
  dimAmbient <- nrow(X)
  dimTangent <- calcTanDim(mfd, dimAmbient=dimAmbient)
  
  if (is.null(weight)) {
    n <- dim(X)[2]
    weight <- rep(1 / n, n)
    if (missing(mu0)) {
      mu0 <- apply(X, 1, mean)
    }
  } else {
    weight <- weight / sum(weight)
    ind <- abs(weight) > 1e-14
    n <- sum(ind)
    X <- X[, ind, drop=FALSE]
    weight <- weight[ind]
    if (missing(mu0)) {
      mu0 <- apply(X*t(replicate(dimAmbient, weight)), 1, sum)
    }
  }

  mu0 <- as.matrix(mu0)
  nStart <- ncol(mu0)

  allRes <- lapply(seq_len(nStart), function(i) {

    mu00 <- mu0[, i]
    it <- 0
    dif <- Inf
    SS <- 0

    while(dif > tol && it < maxit) {
      mu00 <- project(mfd, mu00)
      it <- it + 1
      V <- rieLog(mfd, mu00, X)
      # The Weiszfeld Algorithm. c.f. Fletcher et al (2008)
      D <- norm(mfd, mu00, V)
      indPos <- D >= 1e-10
      nPos <- sum(indPos)

      if (nPos > 0) {
        W <- sum(weight[indPos] / D[indPos])
        sumV <- rowSums(matrix(weight[indPos] / D[indPos], 
                               dimTangent, 
                               sum(indPos), byrow=TRUE) * 
                        V[, indPos, drop=FALSE])
        vk <- sumV / W
      } else {
        vk <- rep(0, dimTangent)
      }

      muNew <- as.numeric(rieExp(mfd, mu00, vk * alpha))
      SSNew <- sum(D[indPos])
      dif <- abs(SS - SSNew) / (SS + tol)

      mu00 <- muNew
      SS <- SSNew
    }

    list(x = mu00, fx = SS, it = it)
  })

  minInd <- which.min(vapply(allRes, `[[`, 1, 'fx'))
  mu0 <- allRes[[minInd]]$x
  it <- allRes[[minInd]]$it

  if (it == maxit) {
    warning('Maximum iteration reached!')
  }

  matrix(mu0)
}


#' @param mu0 A matrix of starting points. Each column corresponds to a starting point. If there are multiple columns, then a multistart algorithm is used. 
#' @param weight A vector of weights for the observations
#' @param tol The threshold for determining convergence
#' @param maxit Maximum iteration
#' @param lam The step length
#' @export
#' @describeIn frechetMean Default method
frechetMean.default <- function(mfd, X, mu0, weight=NULL, tol=1e-9, maxit=1000, lam=0.99) {

  X <- as.matrix(X)
  dimAmbient <- nrow(X)
  dimTangent <- calcTanDim(mfd, dimAmbient=dimAmbient)
  
  if (is.null(weight)) {
    n <- dim(X)[2]
    weight <- rep(1 / n, n)
    if (missing(mu0)) {
      mu0 <- apply(X, 1, mean)
    }
  } else {
    weight <- weight / sum(weight)
    ind <- abs(weight) > 1e-14
    n <- sum(ind)
    X <- X[, ind, drop=FALSE]
    weight <- weight[ind]
    if (missing(mu0)) {
      mu0 <- apply(X*t(replicate(dimAmbient, weight)), 1, sum)
    }
  }

  mu0 <- as.matrix(mu0)
  nStart <- ncol(mu0)

  allRes <- lapply(seq_len(nStart), function(i) {

    mu00 <- mu0[, i]
    it <- 0
    dif <- Inf
    SS <- 0

    while(dif > tol && it < maxit) {
      mu00 <- project(mfd, mu00)
      it <- it + 1
      V <- rieLog(mfd, mu00, X)
      vNew <- as.numeric(rowSums(V * matrix(weight, dimTangent, n, byrow=TRUE)))
      muNew <- as.numeric(rieExp(mfd, mu00, vNew * lam^it))
      SSNew <- sum(V^2)
      dif <- abs(SS - SSNew) / (SS + tol)

      mu00 <- muNew
      SS <- SSNew
    }

    list(x = mu00, fx = SS, it = it)
  })

  minInd <- which.min(vapply(allRes, `[[`, 1, 'fx'))
  mu0 <- allRes[[minInd]]$x
  it <- allRes[[minInd]]$it

  if (it == maxit) {
    warning('Maximum iteration reached!')
  }

  matrix(mu0)
}


#' Frechet mean curve of a set of sparsely observed curves on the manifold
#'
#' @param mfd A class instance that represents the Riemannian manifold
#' @param bw The bandwidth
#' @param kernel_type The type of kernel for smoothing
#' @param yin A list of \emph{n} matrices containing the observed values for each individual. Missing values specified by \code{NA}s are supported for dense case (\code{dataType='dense'}).
#' @param xin A list of \emph{n} vectors containing the observation time points for each individual corresponding to y. Each vector should be sorted in ascending order.
#' @param xout The time points where the mean curve shall be evaluated
#' @param npoly The order of the local polynomial smoother
#' @param win A vector \emph{n} numbers. The weight of each individual.
#' 
#' @return A matrix with \code{length(xout)} columns. The \emph{i}th column is the estimated mean curve at \code{xout[i]} 
#' @export
frechetMeanCurve <- function(mfd, bw, kernel_type, xin, 
                             yin, xout, npoly = 1L, 
                             win=rep(1L, length(xin))){
  
  if(is.unsorted(xout)){
      stop('`xout` needs to be sorted in increasing order')
  }
  
  if(all(is.na(win)) || all(is.na(xin)) || all(is.na(yin))){
      stop(' win, xin or yin contain only NAs!')
  }
  
  # Deal with NA/NaN measurement values
  NAinY = is.na(xin) | is.na(yin) | is.na(win)
  if(any(NAinY)){
      win = win[!NAinY]
      xin = xin[!NAinY]
      yin = yin[!NAinY]
  } 
  
  nout <- length(xout)
  # kw <- getKernelWeight(kernel_type, bw, xin, xout, win)
  kw <- getKernelWeight1(kernel_type, bw, xin, xout, win, npoly)

  if (!inherits(mfd, 'Euclidean')) {
    meanCurve <- sapply(1:nout, function(i) frechetMean(mfd, yin, weight=kw[, i]))
    
    # if(npoly == 0) # constant kernel smoothing
    # {
        # could be faster if local compact kernel by drop points with zero weight
    # }
    # else # local linear smoothing
    # {
        # stop('npoly >= 1 not supported yet')
        # #meanCurve <- matrix(0, 3, nout)
    # }
  } else if (inherits(mfd, 'Euclidean')) {
    meanCurve <- yin %*% kw
    # meanCurve <- t(apply(yin, 1, function(x) {
                           # Lwls1D(bw, kernel_type, win, xin, x, xout, npoly)
                   # }))
  }
  return(meanCurve)
}


# This function computes the optimal bandwidth choice for the mean
# function use GCV method by pooling the longitudinal data together. 
# verbose is unused for now
# this is compatible with PACE because the GCV is calculated in a same way

GCVFrechetMeanCurve <- function(mfd, yy, tt, kernel, npoly, dataType, verbose=TRUE) {
  
  # If 'yy' and 't' are vectors "cheat" and break them in 
  # a list of 10 elements                                                                                                                                  
  if ( is.vector(yy) && is.vector(tt) && !is.list(yy) && !is.list(tt) ){
    if (length(tt) < 21) {
        stop("You are trying to use a local linear weight smoother in a vector with less than 21 values.\n")
    }
    myPartition = c(1:10, sample(10, length(tt)-10, replace=TRUE));
    yy = split(yy, myPartition)
    tt = split(tt, myPartition)
    dataType = 'Sparse';
  }
  
  # pool all observations across subjects and re-order them so that
  # t is ascending
  t = unlist(tt);
  y = do.call(cbind, lapply(yy, unlist)) # unlist(yy)[order(t)];
  torder <- order(t)
  t = t[torder]
  y = y[, torder]
  
  # r = diff(range(t))
  N = length(t);
  r = t[N] - t[1];  
  
  # Specify the starting bandwidth candidates
  if (dataType == "Sparse") {
      dstar = fdapace:::Minb(t, npoly+2)
      if ( dstar > r*0.25){
          dstar = dstar * 0.75
          warning( c( "The min bandwidth choice is too big, reduce to ", dstar, "!\n"))
      }
      h0 = 2.5 * dstar
  } else if (dataType == "DenseWithMV") {
      h0 = 2.0 * fdapace:::Minb(t, npoly+1)
  } else {
      h0 = 1.5 * fdapace:::Minb(t, npoly+1)
  }  
  if ( is.nan(h0) ){
      if ( kernel == "gauss" ){
          h0 = 0.2 * r
      } else {
          stop("The data is too sparse, no suitable bandwidth can be found! Try Gaussian kernel instead!\n")
      }
  }  
  h0 <- min(h0, r)
  q = (r / (4 * h0))^(1/9);
  bwCandidates = sort(q^(0:9)*h0)
  
  # idx = apply(X= sapply(X=t, FUN='==',  ...=sort(unique(t)) ), MARGIN=2, FUN=which)  
  idx =  pracma::uniq(t)$n
  # This is to make sure we get the same as MATLAB PACE 
  # I would write them in a function (equivalent of mykernel.m) if it is worth it 
  # Similarly there is no reason to repeat the FOR-loop twice; this too can go into a seperate function
  k0_candidates <- list('quar' = 0.9375,  'epan' = 0.7500, 'rect' = 0.5000, 
                        'gausvar' = 0.498677, 'gausvar1' = 0.598413,  'gausvar2' = 0.298415, 'other' = 0.398942)
  if( any(names(k0_candidates) == kernel)){ 
      k0 = as.numeric(k0_candidates[kernel])
  } else { 
      k0 =  as.numeric(k0_candidates$other)
  }
  
  gcvScores <- c()

  # Get the corresponding GCV scores 
  for(i in 1:length(bwCandidates)) {
      # newmu = Lwls1D(bwCandidates[i], kern=kernel, npoly=npoly, nder=nder, xin = t, yin= y, xout= sort(unique(t)))[idx]
    # browser()
    # if (!inherits(mfd, 'Euclidean')) {
      # newmu = frechetMeanCurve(mfd, bwCandidates[i], 
                               # kernel_type=kernel, 
                               # npoly=npoly, 
                               # xin = t,
                               # yin= y, 
                               # win = rep(1, dim(y)[2]),
                               # xout= sort(unique(t)))[, idx]
    # } else if (inherits(mfd, 'Euclidean')) {
      # newmu <- t(apply(y, 1, function(x) {
          # Lwls1D(bwCandidates[i], kernel_type=kernel, xin=t, yin=x, npoly=npoly, xout=sort(unique(t)))
      # }))[, idx]
    # }
    newmu <- frechetMeanCurve(mfd, bwCandidates[i], 
                              kernel_type=kernel, 
                              npoly=npoly, 
                              xin = t,
                              yin= y, 
                              win = rep(1, dim(y)[2]),
                              xout= sort(unique(t)))[, idx]
    cvsum = sum((newmu -y)^2)
    gcvScores[i] =cvsum/(1-(r*k0)/(N*bwCandidates[i]))^2
  }
  
  # If no bandwith gives a finite gcvScore increase the candidate bandwith and retry on a finer grid
  if (all((is.infinite(gcvScores)))) {
      bwCandidates = seq( max(bwCandidates), r, length.out = 2*length(bwCandidates))
      for(i in 1:length(bwCandidates)){
          # newmu = Lwls1D(bwCandidates[i], kern=kernel, npoly=npoly, nder=nder, xin = t, yin= y, xout= sort(unique(t)))[idx]
        # if (!inherits(mfd, 'Euclidean')) {
        newmu <- frechetMeanCurve(mfd, bwCandidates[i], 
                                  kernel_type=kernel, 
                                  npoly=npoly, 
                                  xin = t,
                                  yin= y, 
                                  win = rep(1, dim(y)[2]),
                                  xout= sort(unique(t)))[, idx]
        # } else if (inherits(mfd, 'Euclidean')) {
          # newmu <- t(apply(y, 1, function(x) {
                             # Lwls1D(bwCandidates[i], kernel_type=kernel, xin=t, yin=x, 
                                    # npoly=npoly, xout=sort(unique(t)))
                           # }))[, idx]
        # }
          cvsum = sum((newmu -y)^2 )
          gcvScores[i] =cvsum/(1-(r*k0)/(N*bwCandidates[i]))^2
      }
  }
  
  # If the problem persist we clearly have too sparse data
  if(all((is.infinite(gcvScores)))){
    stop("The data is too sparse, no suitable bandwidth can be found! Try Gaussian kernel instead!\n")      
  }
  
  bInd = which(gcvScores == min(gcvScores));
  bScr = gcvScores[bInd][1]
  bOpt = max(bwCandidates[bInd]); 
  
  if( bOpt == r){
    warning("data is too sparse, optimal bandwidth includes all the data!You may want to change to Gaussian kernel!\n")
  }
  bOptList <- list( 'bOpt' = bOpt, 'bScore' = bScr) 
  return( bOptList)
}

